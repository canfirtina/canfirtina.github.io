<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    
    <!-- Website verification -->
    <meta name="google-site-verification" content="">
<!-- Avoid warning on Google Chrome
        Error with Permissions-Policy header: Origin trial controlled feature not enabled: 'interest-cohort'.
        see https://stackoverflow.com/a/75119417
    -->
    <meta http-equiv="Permissions-Policy" content="interest-cohort=()">

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Tools | Can  Firtina</title>
    <meta name="author" content="Can  Firtina">
    <meta name="description" content="">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.3/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://canfirtina.com/tools/">

    <!-- Dark Mode -->
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/">Can <span class="font-weight-bold">Firtina </span></a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">About</a>
              </li>
              

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">Publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/talks/">Talks &amp; Service</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/teaching/">Teaching</a>
              </li>
              <li class="nav-item active">
                <a class="nav-link" href="/tools/">Tools<span class="sr-only">(current)</span></a>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      
        <!-- page.html -->
        <div class="post">

          <header class="post-header">
            <h1 class="post-title">Tools</h1>
            <p class="post-description"></p>
          </header>

          <article>
            <h2 id="github-repositories">GitHub Repositories</h2>

<div class="repositories d-flex flex-wrap flex-md-row flex-column justify-content-between align-items-center">
  
    



<div class="repo p-2 text-center">
  <a href="https://github.com/CMU-SAFARI/RawHash" rel="external nofollow noopener" target="_blank">
    <img class="repo-img-light w-100" alt="CMU-SAFARI/RawHash" src="https://github-readme-stats.vercel.app/api/pin/?username=CMU-SAFARI&amp;repo=RawHash&amp;theme=default&amp;show_owner=true">
    <img class="repo-img-dark w-100" alt="CMU-SAFARI/RawHash" src="https://github-readme-stats.vercel.app/api/pin/?username=CMU-SAFARI&amp;repo=RawHash&amp;theme=dark&amp;show_owner=true">
  </a>
</div>

  
    



<div class="repo p-2 text-center">
  <a href="https://github.com/CMU-SAFARI/BLEND" rel="external nofollow noopener" target="_blank">
    <img class="repo-img-light w-100" alt="CMU-SAFARI/BLEND" src="https://github-readme-stats.vercel.app/api/pin/?username=CMU-SAFARI&amp;repo=BLEND&amp;theme=default&amp;show_owner=true">
    <img class="repo-img-dark w-100" alt="CMU-SAFARI/BLEND" src="https://github-readme-stats.vercel.app/api/pin/?username=CMU-SAFARI&amp;repo=BLEND&amp;theme=dark&amp;show_owner=true">
  </a>
</div>

  
    



<div class="repo p-2 text-center">
  <a href="https://github.com/CMU-SAFARI/ApHMM-GPU" rel="external nofollow noopener" target="_blank">
    <img class="repo-img-light w-100" alt="CMU-SAFARI/ApHMM-GPU" src="https://github-readme-stats.vercel.app/api/pin/?username=CMU-SAFARI&amp;repo=ApHMM-GPU&amp;theme=default&amp;show_owner=true">
    <img class="repo-img-dark w-100" alt="CMU-SAFARI/ApHMM-GPU" src="https://github-readme-stats.vercel.app/api/pin/?username=CMU-SAFARI&amp;repo=ApHMM-GPU&amp;theme=dark&amp;show_owner=true">
  </a>
</div>

  
    



<div class="repo p-2 text-center">
  <a href="https://github.com/CMU-SAFARI/AirLift" rel="external nofollow noopener" target="_blank">
    <img class="repo-img-light w-100" alt="CMU-SAFARI/AirLift" src="https://github-readme-stats.vercel.app/api/pin/?username=CMU-SAFARI&amp;repo=AirLift&amp;theme=default&amp;show_owner=true">
    <img class="repo-img-dark w-100" alt="CMU-SAFARI/AirLift" src="https://github-readme-stats.vercel.app/api/pin/?username=CMU-SAFARI&amp;repo=AirLift&amp;theme=dark&amp;show_owner=true">
  </a>
</div>

  
    



<div class="repo p-2 text-center">
  <a href="https://github.com/CMU-SAFARI/Apollo" rel="external nofollow noopener" target="_blank">
    <img class="repo-img-light w-100" alt="CMU-SAFARI/Apollo" src="https://github-readme-stats.vercel.app/api/pin/?username=CMU-SAFARI&amp;repo=Apollo&amp;theme=default&amp;show_owner=true">
    <img class="repo-img-dark w-100" alt="CMU-SAFARI/Apollo" src="https://github-readme-stats.vercel.app/api/pin/?username=CMU-SAFARI&amp;repo=Apollo&amp;theme=dark&amp;show_owner=true">
  </a>
</div>

  
    



<div class="repo p-2 text-center">
  <a href="https://github.com/BilkentCompGen/hercules" rel="external nofollow noopener" target="_blank">
    <img class="repo-img-light w-100" alt="BilkentCompGen/hercules" src="https://github-readme-stats.vercel.app/api/pin/?username=BilkentCompGen&amp;repo=hercules&amp;theme=default&amp;show_owner=true">
    <img class="repo-img-dark w-100" alt="BilkentCompGen/hercules" src="https://github-readme-stats.vercel.app/api/pin/?username=BilkentCompGen&amp;repo=hercules&amp;theme=dark&amp;show_owner=true">
  </a>
</div>

  
    



<div class="repo p-2 text-center">
  <a href="https://github.com/calkan/reproducibility" rel="external nofollow noopener" target="_blank">
    <img class="repo-img-light w-100" alt="calkan/reproducibility" src="https://github-readme-stats.vercel.app/api/pin/?username=calkan&amp;repo=reproducibility&amp;theme=default&amp;show_owner=true">
    <img class="repo-img-dark w-100" alt="calkan/reproducibility" src="https://github-readme-stats.vercel.app/api/pin/?username=calkan&amp;repo=reproducibility&amp;theme=dark&amp;show_owner=true">
  </a>
</div>

  
</div>

<hr>
<h2 id="selected-software">Selected Software</h2>

<p><strong>RawHash, RawHash2 and Rawsamble:</strong> RawHash (and RawHash2) is a hash-based mechanism to map raw nanopore signals to a reference genome in real-time. To achieve this, it 1) generates an index from the reference genome and 2) efficiently and accurately maps the raw signals to the reference genome such that it can match the throughput of nanopore sequencing even when analyzing large genomes (e.g., human genome). Rawsamble builds on the same collision‑resistant hashing framework in a reference‑free setting: it performs an all‑vs‑all search for long overlaps directly between raw signals, outputs a PAF overlap graph, and can drive assemblers such as <strong>miniasm</strong> to generate <em>de novo</em> assemblies—without ever base‑calling the signals.</p>

<p>Below figure shows the overview of the steps that RawHash takes to find matching regions between a reference genome and a raw nanopore signal.</p>

<p align="center" width="100%">
    <img width="50%" src="/assets/img/rawhash_overview.png">
</p>

<p>To efficiently identify similarities between a reference genome and reads, RawHash has two steps, similar to regular read mapping tools, 1) indexing and 2) mapping. The indexing step generates hash values from the expected signal representation of a reference genome and stores them in a hash table. In the mapping step, RawHash generates the hash values from raw signals and queries the hash table generated in the indexing step to find seed matches. To map the raw signal to a reference genome, RawHash performs chaining over the seed matches.</p>

<p>RawHash can be used to map reads from <strong>FAST5, POD5, SLOW5, or BLOW5</strong> files to a reference genome in sequence format.</p>

<p>RawHash performs real-time mapping of nanopore raw signals. When the prefix of reads can be mapped to a reference genome, RawHash will stop mapping and provide the mapping information in PAF format. We follow the similar PAF template used in <a href="https://github.com/skovaka/UNCALLED" rel="external nofollow noopener" target="_blank">UNCALLED</a> and <a href="https://github.com/haowenz/sigmap" rel="external nofollow noopener" target="_blank">Sigmap</a> to report the mapping information.</p>

<p><a href="https://github.com/CMU-SAFARI/RawHash" rel="external nofollow noopener" target="_blank">GitHub Link</a> | <a href="https://academic.oup.com/bioinformatics/article/39/Supplement_1/i297/7210440" rel="external nofollow noopener" target="_blank">RawHash Paper Link (ISMB/ECCB 2023 Proceedings)</a> | <a href="https://arxiv.org/abs/2309.05771" rel="external nofollow noopener" target="_blank">RawHash2 Paper</a></p>

<p><strong>BLEND:</strong> BLEND is a mechanism that can efficiently find fuzzy (approximate) seed matches between sequences to significantly improve the performance and accuracy while reducing the memory space usage of two important applications: 1) finding overlapping reads and 2) read mapping. To achieve this, BLEND provides mechanisms to generate the same hash value for highly similar seeds such that BLEND can find fuzzy seed matches with a single lookup from the hash values of seeds. BLEND can be integrated into any seeding mechanism by properly replacing the hash functions of these seeding technqiues. As proof of work, we integrate the BLEND mechanism into <a href="https://github.com/lh3/minimap2/tree/7358a1ead1adfa89a2d3d0e72ffddd05732f9850" rel="external nofollow noopener" target="_blank">minimap2</a> to generate the hash values for minimizer and strobemer seeds.</p>

<p align="center" width="100%">
    <img width="50%" src="/assets/img/blend_overview.png">
</p>

<p><a href="https://github.com/CMU-SAFARI/BLEND" rel="external nofollow noopener" target="_blank">GitHub Link</a> | <a href="https://academic.oup.com/nargab/article/5/1/lqad004/6993940" rel="external nofollow noopener" target="_blank">BLEND Paper Link (NARGAB)</a></p>

<p><strong>AirLift:</strong> As genome sequencing tools and techniques improve, researchers are able to incrementally assemble more accurate reference genomes, which enable sensitivity in read mapping and downstream analysis such as variant calling. A more sensitive downstream analysis is critical for better understanding the health data of a genome donor. Therefore, read sets from sequenced samples should ideally be mapped to the latest available reference genome. Unfortunately, the increasingly large amount of available genomic data makes it prohibitively expensive to fully re-map each read set to its respective reference genome every time the reference is updated. There are several tools that attempt to accelerate the process of updating a read data set from one reference to another (i.e., remapping) by 1) identifying regions that appear similarly between two references and 2) updating the mapping location of reads that map to any of the identified regions in the old reference to the corresponding similar region in the new reference. The main drawback of existing approaches is that if a read maps to a region in the old reference that does not appear similarly in the new reference, the read cannot be remapped. We find that, as a result of this drawback, a significant portion of annotations are lost when using state-of-the-art remapping tools. To address this major limitation in existing tools, we propose AirLift, a fast and comprehensive technique for moving alignments from one genome to another. AirLift reduces 1) the number of reads that need to be fully mapped from the entire read set by up to 99.99% and 2) the overall execution time to remap read sets between two reference genome versions by 19.6x, 6.6x, and 2.7x for large (human), medium (C. elegans), and small (yeast) reference genomes, respectively. We validate our remapping results with GATK and find that AirLift provides similar rates of identifying ground truth SNPs and INDELs as fully mapping a read set.</p>

<p align="center" width="100%">
    <img width="50%" src="/assets/img/airlift_overview.png">
</p>

<p><a href="https://github.com/CMU-SAFARI/AirLift" rel="external nofollow noopener" target="_blank">GitHub Link</a> | <a href="https://www.biorxiv.org/content/10.1101/2021.02.16.431517v1" rel="external nofollow noopener" target="_blank">bioRxiv</a></p>

<p><strong>Apollo:</strong> Third-generation sequencing technologies can sequence long reads that contain as many as 2 million base pairs. These long reads are used to construct an assembly (i.e. the subject’s genome), which is further used in downstream genome analysis. Unfortunately, third-generation sequencing technologies have high sequencing error rates and a large proportion of base pairs in these long reads is incorrectly identified. These errors propagate to the assembly and affect the accuracy of genome analysis. Assembly polishing algorithms minimize such error propagation by polishing or fixing errors in the assembly by using information from alignments between reads and the assembly (i.e. read-to-assembly alignment information). However, current assembly polishing algorithms can only polish an assembly using reads from either a certain sequencing technology or a small assembly. Such technology-dependency and assembly-size dependency require researchers to (i) run multiple polishing algorithms and (ii) use small chunks of a large genome to use all available readsets and polish large genomes, respectively.We introduce Apollo, a universal assembly polishing algorithm that scales well to polish an assembly of any size (i.e. both large and small genomes) using reads from all sequencing technologies (i.e. second- and third-generation). Our goal is to provide a single algorithm that uses read sets from all available sequencing technologies to improve the accuracy of assembly polishing and that can polish large genomes. Apollo (i) models an assembly as a profile hidden Markov model (pHMM), (ii) uses read-to-assembly alignment to train the pHMM with the Baum-Welch algorithm and (iii) decodes the trained model with the Viterbi algorithm to produce a polished assembly. Our experiments with real readsets demonstrate that Apollo is the only algorithm that (i) uses reads from any sequencing technology within a single run and (ii) scales well to polish large assemblies without splitting the assembly into multiple parts.</p>

<p><a href="https://github.com/CMU-SAFARI/Apollo" rel="external nofollow noopener" target="_blank">GitHub Link</a> | <a href="https://academic.oup.com/bioinformatics/article/36/12/3669/5804978?login=true" rel="external nofollow noopener" target="_blank">Apollo Paper Link (Bioinformatics)</a></p>

<p><strong>ApHMM‑GPU:</strong> ApHMM‑GPU is the first GPU implementation of the Baum–Welch expectation‑maximization algorithm for profile Hidden Markov Models (pHMMs). It accelerates the forward–backward and parameter‑update steps across thousands of CUDA cores, delivering large speed‑ups over CPU baselines and enabling fast, energy‑efficient genome analysis.
<a href="https://github.com/CMU-SAFARI/ApHMM-GPU" rel="external nofollow noopener" target="_blank">GitHub Link</a></p>

<p><strong>Hercules:</strong> Hercules applies profile Hidden Markov Model‑based statistical learning to correct systematic sequencing errors in both DNA and RNA long‑read datasets, boosting the accuracy of downstream mapping and assembly.<br>
<a href="https://github.com/BilkentCompGen/hercules" rel="external nofollow noopener" target="_blank">GitHub Link</a></p>

<p><strong>On Genomic Repeats and Reproducibility:</strong> This repository contains scripts and pipelines that detect, quantify, and report reproducibility issues in popular variant‑calling workflows (e.g., BWA‑MEM + GATK HaplotypeCaller) that stem from repetitive genomic regions, helping researchers build more robust analyses.<br>
<a href="https://github.com/calkan/reproducibility" rel="external nofollow noopener" target="_blank">GitHub Link</a></p>

          </article>

        </div>

      
    </div>

    <!-- Footer -->
    <!--    
    <footer class="fixed-bottom">
      <div class="container mt-0">
      </div>
    </footer> -->

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script>

  <!-- Bootstrap Table -->
  <script defer src="https://unpkg.com/bootstrap-table@1.21.3/dist/bootstrap-table.min.js"></script>

  <!-- Load Common JS -->
  <script src="/assets/js/no_defer.js"></script>
  <script defer src="/assets/js/common.js"></script>
  <script defer src="/assets/js/copy_code.js" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id="></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ window.dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', '');
  </script>
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
